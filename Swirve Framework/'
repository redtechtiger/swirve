// Header
#include "../parser/parser.h"
#include "../netcom/netcom.h" // For constructor / NETCOM functions

// Types
#include <string>
#include <vector>
#include <thread>

// Streams
#include <sstream>
#include <iostream>

// Functions
#include <unistd.h>

// Namespaces
using namespace std;

ActiveParser::ActiveParser(NetworkCommunicator* netcom, ServerModule* serverModule) {
    netcomRef = netcom;
    serverModuleRef = serverModule;

    // Init parsehelper
    parsehelper["getval"] = GETVAL;
    parsehelper["setval"] = SETVAL;
    parsehelper["pwr"] = PWR;
    parsehelper["log"] = LOG;
}

int ActiveParser::getParseHelperVal(const string in) {
    auto parsehelperit = parsehelper.find(in);
    if(parsehelperit==parsehelper.end()) return -1;
    return parsehelperit->second;
}

int ActiveParser::executeDemand(const Demand demand, ServerModule* serverModule) {
    switch(demand.Command) {
	case SETVAL:
	    switch(demand.PrimaryArgument) {
		case PWR:
		    int pwrMode = stoi(demand.DataArgument);
		    if(demand.DataArgument)
		    serverModule->
		    break;

		case LOG:

		    break;
	    }
	    break;

	case GETVAL:
	    switch(demand.PrimaryArgument) {
	    	case PWR:
		    
		    break;

		case LOG:

		    break;
	    }
	    break;
    }
}

int ActiveParser::parseDemand(const std::string buffer, Demand &demand) {
    stringstream bufferSS(buffer);
    string token;
    if(!getline(bufferSS,token,DELIMITER)) return -1;
    string dCommand = token;
    if(!getline(bufferSS,token,DELIMITER)) return -1;
    string dPrimaryArgument = token;
    if(!getline(bufferSS,token,DELIMITER)) return -1;
    string dDataArgument = token;

    // Process values
    int iCommand = getParseHelperVal(dCommand);
    int iPrimaryArgument = getParseHelperVal(dPrimaryArgument);
    if(iCommand!=-1) demand.Command = iCommand;
    if(iPrimaryArgument!=-1) demand.PrimaryArgument = iPrimaryArgument;

    // if(!getline(bufferSS,token,DELIMITER)) return -1; // TODO: IMPLEMENT MULTI SERVER SUPPORT
    // demand.Target = token;
    return 0;
}

void ActiveParser::parseLoop(bool* running, NetworkCommunicator* netcom, ServerModule* serverModule) {
    vector<Connection> connections;
    while(*running) {
	sleep(1);
	cout << "ActiveParser: Fetching data from TCP/IP Daemon..." << endl;
	if(netcom->ReadIncomingConnections(connections)<0) continue;
	for(const auto &connection : connections) {
	    if(connection.buffer[0]==0) continue;
	    cout << "ActiveParser: Debug: Analysing buffer data..." << endl;
	    for(const auto &_char : connection.buffer) {
		cout << static_cast<int>(_char) << " ";
	    }
	    fflush(stdout);
	    cout << "\nActiveParser: Parsing fetched data for " << connection.ip << "..." << endl;
	    Demand demand;
	    if(parseDemand(connection.buffer, demand)<0) continue;
	    cout << "ActiveParser: Parsed data: [Command]->" << demand.Command << "<- [PrimaryArgument]->" << demand.PrimaryArgument << "<- [SecondaryArgument]->"<< demand.DataArgument << "<-" << endl;
	}
    }
}

int ActiveParser::StartParser() {
    runParser = true;
    parserDaemon = thread(&ActiveParser::parseLoop,this,&runParser,netcomRef,serverModuleRef);
    return 0;
}

int ActiveParser::StopParser() {
    runParser = false;
    parserDaemon.join();
    return 0;
}
